[{"id":"c4a2291b6d9cf3b0bc908ac9d2a58ccd","title":"自己设计一个游戏通用的2D摄像机累。Camera2D","content":"在2D游戏开发中，摄像机是一个至关重要的组件，允许开发者控制玩家的视角，决定他们能看到游戏世界的哪些部分。这对于引导玩家的注意力和提供沉浸式体验非常重要，在战斗场景中聚焦于战斗区域；而在探索场景中扩大视野以展示更多的环境细节，跟随主要角色移动，确保玩家始终能够看到控制中的角色和周围的环境，将摄像机焦点对准可交互对象，用来提示玩家这些对象的存在和重要性，还可以用来实现特殊效果，如震动或动态缩放等，在下文中我们将会实现这样一个摄像机类用于自己的游戏。\n\n\n    \n        \n    \n    琪诺兔\n    \n        关注我的哔哩哔哩走进我的生活\n        |\n        关注我的GitHub获得我的代码\n    \n\n\n一个合格的摄像机应该具有以下功能。txt本人习惯已屏幕中心为基准处理数据，并且正向使用坐标，所有以下实现已本人使用舒适维主进行实现，我们来弄一些碎片吧。\n视口控制：设置视口大小适应不同的分辨率和屏幕尺寸。123456void SetCameraCenter(short int Viewport_Width, short int Viewport_Height) &#123;    ViewportWidth = Viewport_Width;    ViewportHeight = Viewport_Height;    ViewportCenterX = ViewportWidth * 0.5f;    ViewportCenterY = ViewportHeight * 0.5f;&#125;\n焦点跟随：视点跟随焦点移动。12345678void SetTarget(float targetX, float targetY) &#123;    TargetX = targetX;    TargetY = targetY;&#125;    void SmoothMoveToPosition(float smoothing = 0.5f) &#123;    CameraFocusX += (targetX - CameraFocusX) * smoothing;    CameraFocusY += (targetY - CameraFocusY) * smoothing;&#125;\n坐标转换：屏幕坐标与世界坐标之间转换，便于处理用户输入和游戏对象的位置。123456789void ScreenToWorld(float screenX, float screenY, float&amp; worldX, float&amp; worldY) const &#123;    worldX = CameraFocusX - (screenX - ViewportCenterX) / Zoom;    worldY = CameraFocusY - (screenY - ViewportCenterY) / Zoom;&#125;void WorldToScreen(float worldX, float worldY, float&amp; screenX, float&amp; screenY) const &#123;    screenX = ViewportCenterX + (CameraFocusX - worldX) * Zoom;    screenY = ViewportCenterY + (CameraFocusY - worldY) * Zoom;&#125;\n缩放功能：适应不同的游戏场景和提供不同的视觉体验。123456float GetScale() const &#123; return Zoom; &#125;void SetScale(float zoom = 1)&#123;    Zoom = zoom;&#125;\n边界限制：设置移动边界，防止摄像机移动到游戏世界之外。12345678910111213141516171819202122232425262728293031void SetWorldSize(float Width, float Height) &#123;    WorldBoundaryLeft = -Width * 0.5f;    WorldBoundaryTop = -Height * 0.5f;    WorldBoundaryRight = Width * 0.5f;    WorldBoundaryBottom = Height * 0.5f;&#125;bool SetWorldBoundaries(float left, float top, float right, float bottom) &#123;    if (left &lt; right &amp;&amp; top &lt; bottom) &#123;        WorldBoundaryLeft = left;        WorldBoundaryTop = top;        WorldBoundaryRight = right;        WorldBoundaryBottom = bottom;        return true;    &#125;    return false;&#125;void ViewportCheckBoundaries() &#123;    float scaledOffsetX = ViewportCenterX / Zoom;    float scaledOffsetY = ViewportCenterY / Zoom;    CameraFocusX = std::max(WorldBoundaryLeft + scaledOffsetX, std::min(CameraFocusX, WorldBoundaryRight - scaledOffsetX));    CameraFocusY = std::max(WorldBoundaryTop + scaledOffsetY, std::min(CameraFocusY, WorldBoundaryBottom - scaledOffsetY));    if (ViewportWidth / Zoom &gt; WorldBoundaryRight - WorldBoundaryLeft) &#123;        CameraFocusX = (WorldBoundaryLeft + WorldBoundaryRight) * 0.5f;    &#125;    if (ViewportHeight / Zoom &gt; WorldBoundaryBottom - WorldBoundaryTop) &#123;        CameraFocusY = (WorldBoundaryTop + WorldBoundaryBottom) * 0.5f;    &#125;&#125;\n平滑过渡：避免视角突变给玩家带来不适。12345678void SmoothMoveToPosition(float targetX, float targetY, float smoothing = 0.5f) &#123;    CameraFocusX += (targetX - CameraFocusX) * smoothing;    CameraFocusY += (targetY - CameraFocusY) * smoothing;&#125;void Scale(float zoom = 1)&#123;    Zoom += zoom;&#125;\n抖动效果：模拟冲击爆炸等效果来增强游戏的氛围和反馈。123456789101112131415void Shake(float intensityX = 5.5f, float intensityY = 5.5f) &#123;    std::uniform_real_distribution&lt;float&gt; disX(-intensityX, intensityX);    std::uniform_real_distribution&lt;float&gt; disY(-intensityY, intensityY);    CameraFocusX += disX(gen);    CameraFocusY += disY(gen);&#125;void ShakeCircle(float intensityX = 5.5f, float intensityY = 5.5f) &#123;    std::uniform_real_distribution&lt;float&gt; disX(-intensityX, intensityX);    std::uniform_real_distribution&lt;float&gt; disY(-intensityY, intensityY);    std::uniform_real_distribution&lt;float&gt; angle(-360.0f, 360.0f);    float radian = angle(gen) / 360 * m_PI * 2;    CameraFocusX += disX(gen) * std::cos(radian);    CameraFocusY += disY(gen) * std::sin(radian);&#125;\n\n此刻Camera2D类的所有碎片都已经获得，我们把他拼起来吧。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142class Camera2D &#123;public:    Camera2D(float Viewport_Width, float Viewport_Height,        float World_Width, float World_Height,        float FocusX = 0, float FocusY = 0) :        ViewportCenterX(Viewport_Width * 0.5f),        ViewportCenterY(Viewport_Height * 0.5f),        ViewportWidth(Viewport_Width),        ViewportHeight(Viewport_Height),        WorldBoundaryLeft(-World_Width * 0.5),        WorldBoundaryTop(-World_Height * 0.5),        WorldBoundaryRight(World_Width * 0.5),        WorldBoundaryBottom(World_Height * 0.5),        TargetX(0),        TargetY(0),        CameraFocusX(FocusX),        CameraFocusY(FocusY),        Zoom(1)&#123;&#125;    ~Camera2D() = default;    void ScreenToWorld(float screenX, float screenY, float&amp; worldX, float&amp; worldY) const &#123;        worldX = CameraFocusX - (screenX - ViewportCenterX) / Zoom;        worldY = CameraFocusY - (screenY - ViewportCenterY) / Zoom;    &#125;    void WorldToScreen(float worldX, float worldY, float&amp; screenX, float&amp; screenY) const &#123;        screenX = ViewportCenterX + (CameraFocusX - worldX) * Zoom;        screenY = ViewportCenterY + (CameraFocusY - worldY) * Zoom;    &#125;    float GetScale() const &#123; return Zoom; &#125;    void SetScale(float zoom = 1)    &#123;        Zoom = zoom;    &#125;    void Scale(float zoom = 1)    &#123;        Zoom += zoom;    &#125;    void SmoothMoveToPosition(float targetX, float targetY, float smoothing = 0.5f) &#123;        CameraFocusX += (targetX - CameraFocusX) * smoothing;        CameraFocusY += (targetY - CameraFocusY) * smoothing;    &#125;    void SetTarget(float targetX, float targetY) &#123;        TargetX = targetX;        TargetY = targetY;    &#125;    void SmoothMoveToTarget(float smoothing = 0.5f) &#123;        CameraFocusX += (TargetX - CameraFocusX) * smoothing;        CameraFocusY += (TargetY - CameraFocusY) * smoothing;    &#125;    void Shake(float intensityX = 5.5f, float intensityY = 5.5f) &#123;        std::uniform_real_distribution&lt;float&gt; disX(-intensityX, intensityX);        std::uniform_real_distribution&lt;float&gt; disY(-intensityY, intensityY);        CameraFocusX += disX(gen);        CameraFocusY += disY(gen);    &#125;    void ShakeCircle(float intensityX = 5.5f, float intensityY = 5.5f) &#123;        std::uniform_real_distribution&lt;float&gt; disX(-intensityX, intensityX);        std::uniform_real_distribution&lt;float&gt; disY(-intensityY, intensityY);        std::uniform_real_distribution&lt;float&gt; angle(-360.0f, 360.0f);        float radian = angle(gen) / 360 * 3.1415926535 * 2;        CameraFocusX += disX(gen) * std::cos(radian);        CameraFocusY += disY(gen) * std::sin(radian);    &#125;    void SetCameraCenter(short int Viewport_Width, short int Viewport_Height) &#123;        ViewportWidth = Viewport_Width;        ViewportHeight = Viewport_Height;        ViewportCenterX = ViewportWidth * 0.5f;        ViewportCenterY = ViewportHeight * 0.5f;    &#125;    void SetFocus(float FocusX, float FocusY) &#123;        CameraFocusX = FocusX;        CameraFocusY = FocusY;    &#125;    void Move(float deltaX, float deltaY) &#123;        CameraFocusX += deltaX;        CameraFocusY += deltaY;    &#125;    float GetFocusX() const &#123; return CameraFocusX; &#125;    float GetFocusY() const &#123; return CameraFocusY; &#125;    void SetWorldSize(float Width, float Height) &#123;        WorldBoundaryLeft = -Width * 0.5f;        WorldBoundaryTop = -Height * 0.5f;        WorldBoundaryRight = Width * 0.5f;        WorldBoundaryBottom = Height * 0.5f;    &#125;    bool SetWorldBoundaries(float left, float top, float right, float bottom) &#123;        if (left &lt; right &amp;&amp; top &lt; bottom) &#123;            WorldBoundaryLeft = left;            WorldBoundaryTop = top;            WorldBoundaryRight = right;            WorldBoundaryBottom = bottom;            return true;        &#125;        return false;    &#125;    void ViewportCheckBoundaries() &#123;        float scaledOffsetX = ViewportCenterX / Zoom;        float scaledOffsetY = ViewportCenterY / Zoom;        CameraFocusX = std::max(WorldBoundaryLeft + scaledOffsetX, std::min(CameraFocusX, WorldBoundaryRight - scaledOffsetX));        CameraFocusY = std::max(WorldBoundaryTop + scaledOffsetY, std::min(CameraFocusY, WorldBoundaryBottom - scaledOffsetY));        if (ViewportWidth / Zoom &gt; WorldBoundaryRight - WorldBoundaryLeft) &#123;            CameraFocusX = (WorldBoundaryLeft + WorldBoundaryRight) * 0.5f;        &#125;        if (ViewportHeight / Zoom &gt; WorldBoundaryBottom - WorldBoundaryTop) &#123;            CameraFocusY = (WorldBoundaryTop + WorldBoundaryBottom) * 0.5f;        &#125;    &#125;    void GetFocusRect(float&amp; left, float&amp; top, float&amp; right, float&amp; bottom) &#123;         left = CameraFocusX - ViewportCenterX;         top = CameraFocusY - ViewportCenterY;         right = CameraFocusX + ViewportCenterX;         bottom = CameraFocusY + ViewportCenterY;    &#125;private:    std::random_device rd;    std::mt19937 gen(rd());    float TargetX, TargetY;    float CameraFocusX, CameraFocusY;    float ViewportCenterX, ViewportCenterY, ViewportWidth, ViewportHeight;    float Zoom, WorldBoundaryLeft, WorldBoundaryTop, WorldBoundaryRight, WorldBoundaryBottom;&#125;;\n\n这是什么?\n","slug":"Camera2D","date":"2024-06-03T16:00:00.000Z","categories_index":"QiNuoTu","tags_index":"教程,游戏开发","author_index":"琪诺兔"},{"id":"09ebe5c5bda45f47de8e5ceef949d407","title":"是琪诺兔啦！(●'◡'●)！","content":"琪诺兔是一种幻想生物，他十分可爱，o( ?_? )o&#x2F;\n\n\n    \n        \n    \n    琪诺兔\n    \n        关注我的哔哩哔哩走进我的生活\n        |\n        关注我的GitHub获得我的代码\n    \n\n\n\n#这是什么？\n","slug":"Iamme","date":"2024-05-30T16:00:00.000Z","categories_index":"QiNuoTu","tags_index":"闲聊","author_index":"琪诺兔"},{"id":"b70f6100253bc795491c2e90fb219480","title":"保姆级！使用网页版在VoidGameSpace中发表文章与图文。Ciallo​～","content":"保姆级！保姆级！保姆级！Ciallo​～！每一步都有图文混合讲解！\n\n\n    \n        \n    \n    琪诺兔\n    \n        关注我的哔哩哔哩走进我的生活\n        |\n        关注我的GitHub获得我的代码\n    \n\n\n第一步，先分叉一个VoidGameSpace的原始库\n1: 点击蓝字进入VoidGameSpace。进入后，会看到这样的页面。\n2: 点击右上角的，Fork，如果不明白全部默认，点击绿色按钮即可。\n3: 此刻你的库中就有了一份分叉文件，第一步完成。\n\n第二步，来到自己的库中，并进入GameDevWebsite项目。\n1: 点击左上角的，点点点，标志。选择，自己名字加上斜杠的&#x2F;GameDevWebsite项目，非常重要！\n2: 这样就进入了自己库中的GameDevWebsite克隆项目。这里的头像变成自己的，就正确了。\n\n第三步，来到，_posts，文件夹。点击项目中的，source，文件夹。在点击，_posts，文件夹这里会有一大堆别人的文件夹，不需要管理。\n第四步，准备文章！此刻，网页上的操作已经完成，回到本地，用自己的名字创建一个文件夹。\n自己的名字！，不要抄我的名字！进入文件夹，使用你任何喜欢的md文件编辑器在其中创建一个文件，然后进入，开始编写。编写参阅，VoidGameSpace。下方的说明。\n\n1: 跳过上面的说明我们创建一个。\n2: 打开，在头部添加以下内容。permalink: 不太好理解，不用担心，请往下看，它是这样的结构，permalink: articles&#x2F;QiNuoTu&#x2F;Demo&#x2F;\narticles: 可以理解为根目录，必须加上。\nQiNuoTu: 这个是我的名字，一个示意，需要修改为你名字文件夹的名称。\nDemo: 这个是你创建的当前文章的文件名，不要扩展名，但要加上，&#x2F;，斜杠在尾部。这样一来，文章头就准备完毕了。\n\n第五步，编写文章！\n1: 在上面的截图可以注意到，文章头下面有一些白字，没错，这个可以当作简介，或者先到言，具体的文章内容需要在，&lt;!-- More --&gt; 标记下书写\n2: 如何添加图片，在文章旁边使用同名创建一个文件夹。\n3: 将图片丢进文件夹中，就可以使用，![ICON](articles/自己名称文件夹名/文件夹名/文件名.后缀名)表达式引用图片了。\n4: 网页链接同理，[名称](链接)，表达式，即可。\n5: 置入代码，只需要使用，```cpp 代码 ```将代码包裹其中即可。\n\n第六步，发表文章。\n1: 回到网页，那一堆名字的文件夹的页面，点击右上角的，上传文件。\n2: 把文件夹拖住丢上去。\n3: 点击绿色按钮。\n4: 之后就可以看到自己的文件夹了。\n5: 点进去！，就可以看到自己的md文件和文件夹什么的了，在提交之前，需要说明，建立文件夹克隆库一类都只需要做一次，每次发布只要弄文章md和图片文件夹上传到自己的文件夹中即可。\n\n第七步，提交！\n1: 点击右上角的GameDevWebsite。\n2: 找到，Contribote，点击绿色按钮！\n2: 填写标题，点击绿色按钮！\n\n等待审核即可！\n这是什么？\n","slug":"CorrectlyReleased","date":"2024-05-29T16:00:00.000Z","categories_index":"QiNuoTu","tags_index":"教程","author_index":"琪诺兔"},{"id":"7ea893389f767e9ee9a1551d4200cbb4","title":"开箱即用平滑插值大合集！OpenEasing！","content":"在游戏或动画制作中，如何让一个对象或色彩等平滑过度，或在两个值之间平滑的自动分布一直以来是新人开发者的一大难题，很多同学没有那么多时间去寻找公式并将他们逐一实现，没关系已经有前人为我们铺好了路。Easing，网站中为我们实现了一系列用于时间缓动的函数与公式，但它并不是C++的，对于超级新手也不太容易使用，于是我花了一些时间对其中的实现进行了一些翻译为C++.\n\n\n    \n        \n    \n    琪诺兔\n    \n        关注我的哔哩哔哩走进我的生活\n        |\n        关注我的GitHub获得我的代码\n    \n\n\n比例的概念可能有些困扰，在以下的实现中，我将他们重新封装为，提供四个参数的版本。\n\n\n\n\n\n\n\n\n\nbegin_: 当前时间&amp;当前是第几段&amp;当前位置，无需担心会被自动计算为比例。\nstart: 开始值&amp;开始时间&amp;开始位置，等。\nend: 结束值&amp;结束时间&amp;结束位置，等。\npercent_: 将开始与结束之间分为多少段。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306int main() &#123;    // 示例    double progress = 0.5; // 进度    double startValue = 0;  // 开始数值    double endValue = 100;  // 结束数值    double segments = 10;   // 分段数    double result = Easing(progress, startValue, endValue, segments);    std::cout &lt;&lt; &quot;Easing price: &quot; &lt;&lt; result &lt;&lt; std::endl;    return 0;&#125;RGBA ColorDifference(const RGBA&amp; start, const RGBA&amp; end, double t) &#123;    return RGBA(start.R + (end.R - start.R) * t,                 start.G + (end.G - start.G) * t,                start.B + (end.B - start.B) * t,                start.A + (end.A - start.A) * t);&#125;double _getOutBounce(double begin_,double end_,double percent_)&#123;    double _st = end_ - begin_;    double _ed = percent_;    if (_st &lt; 1 ÷ 2.75) return _ed * 7.5625 * _st * _st + begin_;    else if (_st &lt; 2 ÷ 2.75) &#123;_st = _st - 1.5 ÷ 2.75; return _ed * (7.5625 * _st * _st + 0.75) + begin_;&#125;    else if (_st &lt; 2.5 ÷ 2.75) &#123;_st = _st - 2.25 ÷ 2.75; return _ed * (7.5625 * _st * _st + 0.9375) + begin_;&#125;    _st = _st - 2.625 ÷ 2.75;    return _ed * (7.5625 * _st * _st + 0.984375) + begin_;&#125;double _getInBounce(double begin_,double end_,double percent_)&#123;    double _ed = end_ - begin_;    return _ed - _getOutBounce (0, _ed, 1 - percent_) + begin_;&#125;double Linear(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    return ((_End - _Start) * percents_ * percents_ + _Start);&#125;double OutQuad(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    return -(_End - _Start) * percents_ * (percents_ - 2) + _Start;&#125;double InOutQuad(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _ts = percents_ * 2;    if (_ts &lt; 1) return (_End - _Start) ÷ 2 * _ts * _ts + _Start;    return -(_End - _Start) ÷ 2 * (_ts * (_ts - 2) - 1) + _Start;&#125;double InCubic(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    return (_End - _Start) * percents_ * percents_ * percents_ + _Start;&#125;double OutCubic(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _st = percents_ - 1;    return (_End - _Start) * (_st * _st * _st + 1) + _Start;&#125;double InOutCubic(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _st = percents_ - 1;    double _ed1 = _End - _Start;    if(_st &lt; 1)return _ed1 ÷ 2 * _st * _st * _st + _Start;    _st = _st - 2;    return _ed1 ÷ 2 * (_st * _st * _st + 2) + _Start;&#125;double InQuart(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    return (_End - _Start) * percents_ * percents_ * percents_ * percents_ + _Start;&#125;double OutQuart(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _st = percents_ - 1;    return -(_End - _Start) * (_st * _st * _st * _st - 1) + _Start;&#125;double InOutQuart(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _st = percents_ * 2;    double _ed1 = _End - _Start;    if (_st &lt; 1) return _ed1 ÷ 2 * _st * _st * _st * _st + _Start;    _st = _st - 2;    return -_ed1 ÷ 2 * (_st * _st * _st * _st - 2) + _Start;&#125;double InQuint(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    return (_End - _Start) * percents_ * percents_ * percents_ * percents_ * percents_ + _Start;&#125;double OutQuint(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _st = percents_ - 1;    double _ed1 = _End - _Start;    return _ed1 * (_st * _st * _st * _st * _st + 1) + _Start;&#125;double InOutQuint(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _st = percents_ * 2;    double _ed1 = _End - _Start;    if (_st &lt; 1) return _ed1 ÷ 2 * _st * _st * _st * _st * _st + _Start;    _st = _st - 2;    return _ed1 ÷ 2 * (_st * _st * _st * _st * _st + 2) + _Start;&#125;double InSine(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _ed1 = _End - _Start;    return -_ed1 * cos (percents_ ÷ 1 * M_PI ÷ 2) + _ed1 + _Start;&#125;   double OutSine(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _ed1 = _End - _Start;    return _ed1 * sin (percents_ ÷ 1 * M_PI ÷ 2) + _Start;&#125;double InOutSine(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _ed1 = _End - _Start;    return _ed1 * pow (2, 10 * (percents_ ÷ 1 - 1)) + _Start;&#125;double OutExpo(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _st = percents_ * 2;    double _ed1 = _End - _Start;    if (_st &lt; 1) return _ed1 ÷ 2 * pow (2, 10 * (_st - 1)) + _Start;    _st = _st - 1;    return _ed1 ÷ 2 * (-pow (2, -10 * _st) + 2) + _Start;&#125;double InCirc(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _ed1 = _End - _Start;    return -_ed1 * (sqrt (1 - percents_ * percents_) - 1) + _Start;&#125;double OutCirc(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _st = percents_ - 1;    double _ed1 = _End - _Start;    return _ed1 * sqrt (1 - _st * _st) + _Start;&#125;double InOutCirc(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _st = percents_ * 2;    double _ed1 = _End - _Start;    if (_st &lt; 1) return -_ed1 ÷ 2 * (sqrt (1 - _st * _st) - 1) + _Start;    _st = _st - 2;    return _ed1 ÷ 2 * (sqrt (1 - _st * _st) + 1) + _Start;&#125;double InBounce(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    return _getInBounce(_Start, _End, percents_);&#125;double OutBounce(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    return _getOutBounce(_Start, _End, percents_);&#125;double InOutBounce(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _ed = _End - _Start;    if (percents_ &lt; 0.5) return _getInBounce (0, _ed, percents_ * 2) * 0.5 + _Start;    return _getOutBounce (0, _ed, percents_ * 2 - 1) * 0.5 + _ed * 0.5 + _Start;&#125;double InBack(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _ed = _End - _Start;    double _s = 1.70158;    return _ed * percents_ * percents_ * ((_s + 1) * percents_ - _s) + _Start;&#125;double OutBack(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _ed = _End - _Start;    double _s = 1.70158;    double _st = percents_ - 1;    return _ed * (_st * _st * ((_s + 1) * _st + _s) + 1) + _Start;&#125;double InOutBack(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    double _ed = _End - _Start;    double _s = 1.70158;    double _st = percents_ * 2;    if (_st &lt; 1)&#123;_s = _s * 1.525; return _ed ÷ 2 * _st * _st * ((_s + 1) * _st - _s) + _Start;&#125;    double _st = _st - 2    double _s = _s * 1.525    return _ed ÷ 2 * (_st * _st * ((_s + 1) * _st + _s) + 2) + _Start;&#125;double InElastic(double _Progress,double _Start,double _End,double _segments)&#123;    double percents_ = _Progress / _segments;    if (percents &lt; 0) percents = 0;    else if (percents &gt; 1) percents = 1;    if(percents_ == 0) return _Start;    if(percents_ == 1) return _End;    double _ed = _End - _Start;    double _d = 1    double _p = _d * 0.3    double _s = 0    double _a = 0    if (_a = 0 || _a &lt; ads(_ed))&#123;_a = _ed; _s = _p ÷ 4&#125; else &#123;_s = _p / (2 * M_PI) * std::asin(_ed / _a);&#125;    double _st = percents - 1;    return -(_a * pow(2, 10 * _st) * sin((_st * _d - _s) * 2 * M_PI / _p)) + _Start;&#125;double OutElastic(double _Progress, double _Start, double _end, double _segments) &#123;    double percents_ = _Progress / _segments;    if (percents_ &lt; 0) percents_ = 0;    else if (percents_ &gt; 1) percents_ = 1;    double _ed = _end - _Start;    double _d = 1;    double _p = _d * 0.3;    double _s = 0;    double _a = 0;    if (_a == 0 || _a &lt; abs(_ed)) &#123;_a = _ed;_s = _p / 4;&#125; else &#123;_s = _p / (2 * M_PI) * asin(_ed / _a);&#125;    return _a * pow(2, -10 * percents) * sin((percents * _d - _s) * 2 * M_PI / _p) + _end;&#125;double InOutElastic(double _progress, double _start, double _end, double _segments) &#123;    double percents_ = _progress / _segments;    if (percents_ &lt; 0) percents_ = 0;    else if (percents_ &gt; 1) percents_ = 1;    double _ed = _end - _start;    double _d = 1;    double _p = _d * 0.3;    double _s = 0;    double _a = 0;    double _st = percents_ * 2;    if (_st == 2) &#123;return _end;&#125;    if (_a == 0 || _a &lt; abs(_ed)) &#123;_a = _ed;_s = _p / 4;&#125; else &#123;_s = _p / (2 * M_PI) * asin(_ed / _a);&#125;    if (_st &lt; 1) &#123;_st -= 1;return -0.5 * _a * pow(2, 10 * _st) * sin((_st * _d - _s) * 2 * M_PI / _p) + _start;&#125;    _st -= 1;    return _a * pow(2, -10 * _st) * sin((_st * _d - _s) * 2 * M_PI / _p) * 0.5 + _end;&#125;double Clerp(double _progress, double _start, double _end, double _segments) &#123;    double percents_ = _progress / _segments;    if (percents_ &lt; 0) percents_ = 0;    else if (percents_ &gt; 1) percents_ = 1;    double _ed = _end - _start;    const double _min = 0;    const double _max = 360;    const double _half = 180;    double _retval = 0;    double _diff = 0;    if (_ed &lt; -_half) &#123;        _diff = (_max - _start + _end) * percents_;        _retval = _start + _diff;    &#125; else if (_ed &gt; _half) &#123;        _diff = -(_max - _end + _start) * percents_;        _retval = _start + _diff;    &#125; else &#123;        _retval = _start + _ed * percents_;    &#125;    return _retval;&#125;double Spring(double _progress, double _start, double _end, double _segments) &#123;    double percents_ = _progress / _segments;    if (percents_ &lt; 0) percents_ = 0;    else if (percents_ &gt; 1) percents_ = 1;    double _st = sin(percents_ * M_PI * (0.2 + 2.5 * percents_ * percents_ * percents_)) * pow(1 - percents_, 2.2) + percents_;    _st = _st * (1 + 1.2 * (1 - percents_));    return _start + (_end - _start) * _st;&#125;double Punch(double _progress, double _start, double _end, double _segments) &#123;    double percents_ = _progress / _segments;    if (percents_ &lt; 0) percents_ = 0;    else if (percents_ &gt; 1) percents_ = 1;    if (percents_ == 0) return 0;    if (percents_ == 1) return 0;    const double _p = 0.3;    double _s = _p / (2 * M_PI) * asin(0);    return _end * pow(2, -10 * percents) * sin((percents - _s) * 2 * M_PI / _p);&#125;\n这是什么！\n","slug":"OpenEasing","date":"2024-05-29T16:00:00.000Z","categories_index":"QiNuoTu","tags_index":"游戏开发","author_index":"琪诺兔"},{"id":"4ee9f7f9db66a32f6be01c9f693942e5","title":"一些开箱即用碰撞检测！AABB","content":"听说有群友已经不满足于，大V老师提供的简单检测方法了，那么让我们为自己的游戏增加更多有趣的碰撞检测罢！全文采用AABB实现，包含矩矩，圆圆，矩圆，角度矩圆，椭圆，点矩，点环，点圆，点椭，等，必要情况下只要根据下文中的算法自行修改或嵌套使用即可！\n\n\n    \n        \n    \n    琪诺兔\n    \n        关注我的哔哩哔哩走进我的生活\n        |\n        关注我的GitHub获得我的代码\n    \n\n\n在下文中，大家可能会发现，为什么没有旋转过的两个矩形的碰撞，那不是AABB了，未来在说。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 定义一个结构体，表示二维空间中的点struct Point_F &#123;    double x; // 点的x坐标    double y; // 点的y坐标&#125;;// 定义一个结构体，表示矩形区域struct RECT &#123;    double left;   // 矩形左边缘的x坐标    double top;    // 矩形上边缘的y坐标    double right;  // 矩形右边缘的x坐标    double bottom; // 矩形下边缘的y坐标&#125;;// 判断点是否在矩形区域内bool AABBPointInside(const Point_F&amp; V, const RECT&amp; RECT) &#123;    return (V.x &gt; RECT.left &amp;&amp; V.x &lt; RECT.right &amp;&amp; V.y &gt; RECT.top &amp;&amp; V.y &lt; RECT.bottom);&#125;// 判断一个矩形是否完全在另一个矩形内部bool AABBRectInside(const RECT&amp; rect1, const RECT&amp; rect2) &#123;    return (rect2.left &gt;= rect1.left &amp;&amp; rect2.right &lt;= rect1.right &amp;&amp; rect2.top &gt;= rect1.top &amp;&amp; rect2.bottom &lt;= rect1.bottom);&#125;// 判断两个矩形是否重叠bool AABBRectOverlap(const RECT&amp; rect1, const RECT&amp; rect2) &#123;    return (rect1.right &lt; rect2.left || rect1.left &gt; rect2.right || rect1.bottom &lt; rect2.top || rect1.top &gt; rect2.bottom) ? false : true;&#125;// 判断矩形与圆形是否重叠，考虑矩形旋转的情况bool AABBRectCircleOverlap(double rectCenterX, double rectCenterY, double rectWidth, double rectHeight, double angle, double circleX, double circleY, double circleRadius) &#123;    // 计算旋转后的向量坐标    double vectorX = circleX - rectCenterX;    double vectorY = circleY - rectCenterY;    double radians = angle * M_PI / 180.0;    double x = vectorX * cos(radians) + vectorY * sin(radians);    double y = vectorY * cos(radians) - vectorX * sin(radians);    // 计算矩形的半宽和半高    double halfWidth = rectWidth * 0.5;    double halfHeight = rectHeight * 0.5;    if (x - circleRadius &lt; halfWidth &amp;&amp; x + circleRadius &gt; -halfWidth) &#123;        if (y - circleRadius &lt; halfHeight &amp;&amp; y + circleRadius &gt; -halfHeight) &#123;            if (x &lt; -halfWidth &amp;&amp; y &lt; -halfHeight)&#123;                if (distance(x, y, -halfWidth, -halfHeight) &gt;= circleRadius) &#123; return true; &#125;            &#125;            else if (x &lt; halfWidth &amp;&amp; y &lt; -halfHeight)&#123;                if (distance(x, y, halfWidth, -halfHeight) &gt;= circleRadius) &#123; return true; &#125;            &#125;            else if (x &gt; halfWidth &amp;&amp; y &gt; halfHeight)&#123;                if (distance(x, y, halfWidth, halfHeight) &gt;= circleRadius) &#123; return true; &#125;            &#125;            else if (x &lt; -halfWidth &amp;&amp; y &gt; halfHeight) &#123;                if (distance(x, y, -halfWidth, halfHeight) &gt;= circleRadius) &#123; return true; &#125;            &#125;        &#125;        return true;    &#125;    return false;&#125;// 判断点是否在圆内bool AABBPointInCircle(double pointX, double pointY, double circleCenterX, double circleCenterY, double circleRadius) &#123;    // 计算点到圆心的距离，判断是否小于等于半径    double dx = pointX - circleCenterX;    double dy = pointY - circleCenterY;    return sqrt(dx * dx + dy * dy) &lt;= circleRadius;&#125;// 判断两个圆是否相交bool AABBCirclesIntersect(double circleCenterX1, double circleCenterY1, double circleRadius1, double circleCenterX2, double circleCenterY2, double circleRadius2) &#123;    // 计算两个圆心之间的距离，判断是否小于等于两个圆的半径之和    double dx = circleCenterX1 - circleCenterX2;    double dy = circleCenterY1 - circleCenterY2;    return sqrt(dx * dx + dy * dy) &lt;= circleRadius1 + circleRadius2;&#125;// 判断点是否在圆环内bool AABBPointInAnnulus(double x, double y, double circleCenterX, double circleCenterY, double circleRadius, double innerThickness, double outerThickness) &#123;    // 计算点到圆心的距离    double dx = x - circleCenterX;    double dy = y - circleCenterY;    double dist = sqrt(dx * dx + dy * dy);    // 判断距离是否在内圆半径和外圆半径之间    return (dist &lt;= circleRadius + outerThickness &amp;&amp; dist &gt;= circleRadius - innerThickness);&#125;// 判断点是否在椭圆内bool AABBPointInEllipse(double centerX, double centerY, double radiusA, double radiusB, double x, double y) &#123;    // 计算点到椭圆中心的距离，并与椭圆的参数化方程比较    double dx = centerX - x;    double dy = centerY - y;    return (dx * dx / (radiusA * radiusA) + dy * dy / (radiusB * radiusB)) &lt;= 1;&#125;\n","slug":"一些包围盒类碰撞检测算法","date":"2024-05-27T16:00:00.000Z","categories_index":"QiNuoTu","tags_index":"游戏开发","author_index":"琪诺兔"}]